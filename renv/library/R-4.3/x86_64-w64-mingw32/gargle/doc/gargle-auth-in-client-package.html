<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>How to use gargle for auth in a client package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">How to use gargle for auth in a client
package</h1>



<p>gargle provides common infrastructure for use with Google APIs. This
vignette describes one possible design for using gargle to deal with
auth, in a client package that provides a high-level wrapper for a
specific API.</p>
<p>There are frequent references to <a href="https://googledrive.tidyverse.org">googledrive</a>, which uses the
design described here, along with <a href="https://bigrquery.r-dbi.org">bigrquery</a> (v1.2.0 and higher), <a href="https://gmailr.r-lib.org">gmailr</a> (v1.0.0 and higher), and <a href="https://googlesheets4.tidyverse.org">googlesheets4</a> (the
successor to <a href="https://github.com/jennybc/googlesheets">googlesheets</a>).</p>
<div id="key-choices" class="section level2">
<h2>Key choices</h2>
<p>Getting a token requires several pieces of information and there are
stark differences in how much users (need to) know or control about this
process. Let’s review them, with an eye towards identifying the
responsibilities of the package author versus the user.</p>
<ul>
<li>Overall config: OAuth client and API key. Who provides?</li>
<li>Token-level properties: Google identity (email) and scopes.</li>
<li>Request-level: Who manages tokens and injects them into
requests?</li>
</ul>
<div id="user-facing-auth" class="section level3">
<h3>User-facing auth</h3>
<p>In googledrive, the main user-facing auth function is
<code>googledrive::drive_auth()</code>. Here is its definition (at least
approximately, remember this is static code):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># googledrive::</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>drive_auth <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">email =</span> gargle<span class="sc">::</span><span class="fu">gargle_oauth_email</span>(),</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>                       <span class="at">path =</span> <span class="cn">NULL</span>,</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>                       <span class="at">scopes =</span> <span class="st">&quot;https://www.googleapis.com/auth/drive&quot;</span>,</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>                       <span class="at">cache =</span> gargle<span class="sc">::</span><span class="fu">gargle_oauth_cache</span>(),</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>                       <span class="at">use_oob =</span> gargle<span class="sc">::</span><span class="fu">gargle_oob_default</span>(),</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>                       <span class="at">token =</span> <span class="cn">NULL</span>) {</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>  <span class="co"># this catches a common error, where the user passes JSON for an OAuth client</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>  <span class="co"># to the `path` argument, which only expects a service account token</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>  gargle<span class="sc">::</span><span class="fu">check_is_service_account</span>(path, <span class="at">hint =</span> <span class="st">&quot;drive_auth_configure&quot;</span>)</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>  cred <span class="ot">&lt;-</span> gargle<span class="sc">::</span><span class="fu">token_fetch</span>(</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>    <span class="at">scopes =</span> scopes,</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>    <span class="at">client =</span> <span class="fu">drive_oauth_client</span>() <span class="sc">%||%</span> <span class="er">&lt;</span>BUILT_IN_DEFAULT_CLIENT<span class="sc">&gt;</span>,</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>    <span class="at">email =</span> email,</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>    <span class="at">path =</span> path,</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>    <span class="at">package =</span> <span class="st">&quot;googledrive&quot;</span>,</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a>    <span class="at">cache =</span> cache,</span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a>    <span class="at">use_oob =</span> use_oob,</span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>    <span class="at">token =</span> token</span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a>  )</span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">inherits</span>(cred, <span class="st">&quot;Token2.0&quot;</span>)) {</span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a>    <span class="co"># throw an informative error here</span></span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a>  }</span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a>  .auth<span class="sc">$</span><span class="fu">set_cred</span>(cred)</span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a>  .auth<span class="sc">$</span><span class="fu">set_auth_active</span>(<span class="cn">TRUE</span>)</span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a>  <span class="fu">invisible</span>()</span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a>}</span></code></pre></div>
<p><code>drive_auth()</code> is called automatically upon the first need
of a token and that can lead to user interaction, but does not
necessarily do so. <code>drive_auth()</code> can be called explicitly by
the user, but usually that is not necessary. <code>token_fetch()</code>
is described in the <code>vignette(&quot;how-gargle-gets-tokens&quot;)</code>. The
internal <code>.auth</code> object maintains googledrive’s auth state
and is explained next.</p>
</div>
<div id="auth-state" class="section level3">
<h3>Auth state</h3>
<p>A client package can use an internal object of class
<code>gargle::AuthState</code> to hold the auth state. In googledrive,
the main auth file defines a placeholder <code>.auth</code> object:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>.auth <span class="ot">&lt;-</span> <span class="cn">NULL</span></span></code></pre></div>
<p>The actual initialization happens in <code>.onLoad()</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>.onLoad <span class="ot">&lt;-</span> <span class="cf">function</span>(libname, pkgname) {</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  utils<span class="sc">::</span><span class="fu">assignInMyNamespace</span>(</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>    <span class="st">&quot;.auth&quot;</span>,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>    gargle<span class="sc">::</span><span class="fu">init_AuthState</span>(<span class="at">package =</span> <span class="st">&quot;googledrive&quot;</span>, <span class="at">auth_active =</span> <span class="cn">TRUE</span>)</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>  )</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>  </span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>  <span class="co"># other stuff</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>}</span></code></pre></div>
<p>The initialization of <code>.auth</code> is done this way to ensure
that we get an instance of the <code>AuthState</code> class using the
current, installed version of gargle (vs. the ambient version from
whenever gargle was built, perhaps by CRAN).</p>
<p>An <code>AuthState</code> instance has other fields which, in this
googledrive example, are not set at this point. The OAuth
<code>client</code> and <code>api_key</code> are configurable by the
user and, when <code>NULL</code>, downstream functions can fall back to
internal credentials. The <code>cred</code> field is populated by the
first call to <code>drive_auth()</code> (direct or indirectly via
<code>drive_token()</code>).</p>
</div>
<div id="oauth-client" class="section level3">
<h3>OAuth client</h3>
<p>Most users should present OAuth user credentials to Google APIs.
However, most users would love to be spared the fiddly details
surrounding this. The OAuth client is one example. (Historically,
following the lead of the httr package, we have used the term OAuth
<em>app</em>, but we now use the term OAuth <em>client</em>.) The client
is a component that most users do not even know about and they are
content to use the same client for all work through a wrapper package:
possibly, the client built into the package.</p>
<p>There is a field in the <code>.auth</code> auth state to hold the
OAuth <code>client</code>. Exported auth helpers,
<code>drive_oauth_client()</code> and
<code>drive_auth_configure()</code>, retrieve and modify the current
client to support users who want to (or must) take that level of
control.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">library</span>(googledrive)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># first: download the OAuth client as a JSON file</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="fu">drive_auth_configure</span>(</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>  <span class="at">path =</span> <span class="st">&quot;/path/to/the/JSON/that/was/downloaded/from/gcp/console.json&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>)</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="fu">drive_oauth_client</span>()</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt; &lt;gargle_oauth_client&gt;</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt; name: acme-corp-google-client</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt; id: 123456789.apps.googleusercontent.com</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt; secret: &lt;REDACTED&gt;</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co">#&gt; type: installed</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="co">#&gt; redirect_uris: http://localhost</span></span></code></pre></div>
<p>Do not “borrow” an OAuth client ID and secret from gargle or any
other package; always use credentials associated with your package or
provided by your user. Per the Google User Data Policy <a href="https://developers.google.com/terms/api-services-user-data-policy" class="uri">https://developers.google.com/terms/api-services-user-data-policy</a>,
your application must accurately represent itself when authenticating to
Google API services.</p>
<p>Some APIs and scopes are considered so sensitive that is essentially
impossible for a package to provide a built-in OAuth client. Users
<strong>must</strong> get and configure their own client. Among the
packages mentioned as examples, this is true of gmailr.</p>
</div>
<div id="api-key" class="section level3">
<h3>API key</h3>
<p>Some Google APIs can be used in an unauthenticated state, if and only
if requests include an API key. For example, this is a great way to read
a Google Sheet that is world-readable or readable by “anyone with a
link” from a Shiny app, thereby designing away the need to manage user
credentials on the server.</p>
<p>The user can provide their own API key via
<code>drive_auth_configure(api_key =)</code> and retrieve that value
with <code>drive_api_key()</code>, just as with the OAuth client. The
API key is stored in the <code>api_key</code> field of the
<code>.auth</code> auth state.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">library</span>(googledrive)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="fu">drive_auth_configure</span>(<span class="at">api_key =</span> <span class="st">&quot;123456789&quot;</span>)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="fu">drive_api_key</span>()</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#&gt; &quot;123456789&quot;</span></span></code></pre></div>
<p>Many users aren’t motivated to take this level of control and
appreciate when a package provides a built-in default API key. As with
the client, packages should obtain their own API key and not borrow the
gargle or tidyverse key.</p>
<p>Some APIs are not usable without a token, in which case a wrapper
package may not even expose functionality for managing an API key. Among
the packages mentioned as examples, this is true of bigrquery.</p>
</div>
<div id="email-or-google-identity" class="section level3">
<h3>Email or Google identity</h3>
<p>In contrast to the OAuth client and API key, every user must express
which identity they wish to present to the API. This is a familiar
concept and users expect to specify this. Since users may have more than
one Google account, it’s quite likely that they will want to switch
between accounts, even within a single R session, or that they might
want to explicitly declare the identity to be used in a specific script
or app.</p>
<p>That explains why <code>drive_auth()</code> has the optional
<code>email</code> argument that lets users proactively specify their
identity. <code>drive_auth()</code> is usually called indirectly upon
first need, but a user can also call it proactively in order to specify
their target <code>email</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># googledrive::</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="fu">drive_auth</span>(<span class="at">email =</span> <span class="st">&quot;janedoe_work@gmail.com&quot;</span>)</span></code></pre></div>
<p>If <code>email</code> is not given, gargle also checks for an option
named <code>&quot;gargle_oauth_email&quot;</code>. The <code>email</code> is used
to look up tokens in the cache and, if no suitable token is found, it is
used to pre-configure the OAuth chooser in the browser. Read more in the
help for <code>gargle::gargle_oauth_email()</code>.</p>
</div>
<div id="scopes" class="section level3">
<h3>Scopes</h3>
<p>Most users have no concept of scopes. They just know they want to
work with, e.g., Google Drive or Google Sheets. A client package can
usually pick sensible default scopes, that will support what most users
want to do.</p>
<p>Here’s a reminder of the signature of
<code>googledrive::drive_auth()</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># googledrive::</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>drive_auth <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">email =</span> gargle<span class="sc">::</span><span class="fu">gargle_oauth_email</span>(),</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>                       <span class="at">path =</span> <span class="cn">NULL</span>,</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>                       <span class="at">scopes =</span> <span class="st">&quot;https://www.googleapis.com/auth/drive&quot;</span>,</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>                       <span class="at">cache =</span> gargle<span class="sc">::</span><span class="fu">gargle_oauth_cache</span>(),</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>                       <span class="at">use_oob =</span> gargle<span class="sc">::</span><span class="fu">gargle_oob_default</span>(),</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>                       <span class="at">token =</span> <span class="cn">NULL</span>) { ... }</span></code></pre></div>
<p>googledrive ships with a default scope, but a motivated user could
call <code>drive_auth()</code> preemptively at the start of the session
and request different scopes. For example, if they intend to only read
data and want to guard against inadvertent file modification, they might
opt for the <code>drive.readonly</code> scope.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># googledrive::</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="fu">drive_auth</span>(<span class="at">scopes =</span> <span class="st">&quot;https://www.googleapis.com/auth/drive.readonly&quot;</span>)</span></code></pre></div>
</div>
<div id="oauth-cache-and-out-of-bound-auth" class="section level3">
<h3>OAuth cache and Out-of-bound auth</h3>
<p>The location of the token cache and whether to prefer out-of-bound
auth are two aspects of OAuth where most users are content to go along
with sensible default behavior. For those who want to exert control,
that can be done in direct calls to <code>drive_auth()</code> or by
configuring an option. Read the help for
<code>gargle::gargle_oauth_cache()</code> and
<code>gargle::gargle_oob_default()</code> and
<code>vignette(&quot;auth-from-web&quot;)</code> for more.</p>
</div>
</div>
<div id="overview-of-mechanics" class="section level2">
<h2>Overview of mechanics</h2>
<p>Here’s a concrete outline of how one could set up a client package to
get its auth functionality from gargle.</p>
<ol style="list-style-type: decimal">
<li>Add gargle to your package’s <code>Imports</code>.</li>
<li>Create a file <code>R/YOURPKG_auth.R</code>.</li>
<li>Create an internal <code>gargle::AuthClass</code> object to hold
auth state. Follow the googledrive example above.</li>
<li>Define standard functions for the auth interface between gargle and
your package; do this in <code>R/YOURPKG_auth.R</code>. Examples: <a href="https://github.com/tidyverse/googledrive/blob/main/R/drive_auth.R"><code>tidyverse/googledrive/R/drive_auth.R</code></a>
and <a href="https://github.com/r-dbi/bigrquery/blob/main/R/bq-auth.R"><code>r-dbi/bigrquery/R/bq_auth.R</code></a>.</li>
<li>Use gargle’s roxygen helpers to create the docs for your auth
functions. This relieves you from writing docs and you inherit standard
wording. See previously cited examples for inspiration.</li>
<li>Use the functions <code>YOURPKG_token()</code> and
<code>YOURPKG_api_key()</code> (defined in the standard auth interface)
to insert a token or API key in your package’s requests.</li>
</ol>
</div>
<div id="getting-that-first-token" class="section level2">
<h2>Getting that first token</h2>
<p>I focus on early use, by the naive user, with the OAuth flow. When
the user first calls a high-level googledrive function such as
<code>drive_find()</code>, a Drive request is ultimately generated with
a call to <code>googledrive::request_generate()</code>. Here is its
definition, at least approximately:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># googledrive::</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>request_generate <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">endpoint =</span> <span class="fu">character</span>(),</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>                             <span class="at">params =</span> <span class="fu">list</span>(),</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>                             <span class="at">key =</span> <span class="cn">NULL</span>,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>                             <span class="at">token =</span> <span class="fu">drive_token</span>()) {</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>  ept <span class="ot">&lt;-</span> <span class="fu">drive_endpoint</span>(endpoint)</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.null</span>(ept)) {</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>    <span class="co"># throw error about unrecognized endpoint</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>  }</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>  <span class="do">## modifications specific to googledrive package</span></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a>  params<span class="sc">$</span>key <span class="ot">&lt;-</span> key <span class="sc">%||%</span> params<span class="sc">$</span>key <span class="sc">%||%</span></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a>    <span class="fu">drive_api_key</span>() <span class="sc">%||%</span> <span class="er">&lt;</span>BUILT_IN_DEFAULT_API_KEY<span class="sc">&gt;</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(ept<span class="sc">$</span>parameters<span class="sc">$</span>supportsAllDrives)) {</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a>    params<span class="sc">$</span>supportsAllDrives <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a>  }</span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a>  req <span class="ot">&lt;-</span> gargle<span class="sc">::</span><span class="fu">request_develop</span>(<span class="at">endpoint =</span> ept, <span class="at">params =</span> params)</span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a>  gargle<span class="sc">::</span><span class="fu">request_build</span>(</span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a>    <span class="at">path =</span> req<span class="sc">$</span>path,</span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a>    <span class="at">method =</span> req<span class="sc">$</span>method,</span>
<span id="cb9-22"><a href="#cb9-22" tabindex="-1"></a>    <span class="at">params =</span> req<span class="sc">$</span>params,</span>
<span id="cb9-23"><a href="#cb9-23" tabindex="-1"></a>    <span class="at">body =</span> req<span class="sc">$</span>body,</span>
<span id="cb9-24"><a href="#cb9-24" tabindex="-1"></a>    <span class="at">token =</span> token</span>
<span id="cb9-25"><a href="#cb9-25" tabindex="-1"></a>  )</span>
<span id="cb9-26"><a href="#cb9-26" tabindex="-1"></a>}</span></code></pre></div>
<p><code>googledrive::request_generate()</code> is a thin wrapper around
<code>gargle::request_develop()</code> and
<code>gargle::request_build()</code> that only implements details
specific to googledrive, before delegating to more general functions in
gargle. The <code>vignette(&quot;request-helper-functions&quot;)</code> documents
these gargle functions.</p>
<p><code>googledrive::request_generate()</code> gets a token with
<code>drive_token()</code>, which is defined like so:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># googledrive::</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>drive_token <span class="ot">&lt;-</span> <span class="cf">function</span>() {</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">isFALSE</span>(.auth<span class="sc">$</span>auth_active)) {</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>    <span class="fu">return</span>(<span class="cn">NULL</span>)</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>  }</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">drive_has_token</span>()) {</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>    <span class="fu">drive_auth</span>()</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>  }</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>  httr<span class="sc">::</span><span class="fu">config</span>(<span class="at">token =</span> .auth<span class="sc">$</span>cred)</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>}</span></code></pre></div>
<p>where <code>drive_has_token()</code> in a helper defined as:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># googledrive::</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>drive_has_token <span class="ot">&lt;-</span> <span class="cf">function</span>() {</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="fu">inherits</span>(.auth<span class="sc">$</span>cred, <span class="st">&quot;Token2.0&quot;</span>)</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>}</span></code></pre></div>
<p>By default, auth is active, and, for a fresh start, we won’t have a
token stashed in <code>.auth</code> yet. So this will result in a call
to <code>drive_auth()</code> to obtain a credential, which is then
cached in <code>.auth$cred</code> for the remainder of the session. All
subsequent calls to <code>drive_token()</code> will just spit back this
token.</p>
<p>Above, we discussed scenarios where an advanced user might call
<code>drive_auth()</code> proactively, with non-default arguments,
possibly even loading a service token or using alternative flows, like
an external account. Any token loaded in that way is stashed in
<code>.auth$cred</code> and will be returned by subsequent calls to
<code>drive_token()</code>.</p>
<p>Multiple gargle-using packages can use a shared token by obtaining a
suitably scoped token with one package, then registering that token with
the other packages. For example, the default scope requested by
googledrive is also sufficient for operations available in
googlesheets4. You could use a shared token like so:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">library</span>(googledrive)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="fu">library</span>(googlesheets4)</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="fu">drive_auth</span>(<span class="at">email =</span> <span class="st">&quot;jane_doe@example.com&quot;</span>) <span class="co"># gets a suitably scoped token</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>                                           <span class="co"># and stashes for googledrive use</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="fu">gs4_auth</span>(<span class="at">token =</span> <span class="fu">drive_token</span>())            <span class="co"># registers token with googlesheets4</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a><span class="co"># now work with both packages freely ...</span></span></code></pre></div>
<p>It is important to make sure that the token-requesting package
(googledrive, above) is using an OAuth client for which all the
necessary APIs and scopes are enabled.</p>
</div>
<div id="auth-interface" class="section level2">
<h2>Auth interface</h2>
<p>The exported functions like <code>drive_auth()</code>,
<code>drive_token()</code>, etc. constitute the auth interface between
googledrive and gargle and are centralized in <a href="https://github.com/tidyverse/googledrive/blob/main/R/drive_auth.R"><code>tidyverse/googledrive/R/drive_auth.R</code></a>.
That is a good template for how to use gargle to manage auth in a client
package. In addition, the docs for these gargle-backed functions are
generated automatically from standard information maintained in the
gargle package.</p>
<ul>
<li><code>drive_token()</code> retrieves the current credential, in a
form that is ready for inclusion in HTTP requests. If
<code>auth_active</code> is <code>TRUE</code> and <code>cred</code> is
<code>NULL</code>, <code>drive_auth()</code> is called to obtain a
credential. If <code>auth_active</code> is <code>FALSE</code>,
<code>NULL</code> is returned; client packages should be designed to
fall back to including an API key in affected HTTP requests, if sensible
for the API.</li>
<li><code>drive_auth()</code> ensures we are dealing with an
authenticated user and have a credential on hand with which to place
authorized requests. Sets <code>auth_active</code> to <code>TRUE</code>.
Can be called directly, but <code>drive_token()</code> will also call it
as needed.</li>
<li><code>drive_deauth()</code> clears the current token. It might also
toggle <code>auth_active</code>, depending on the features of the target
API. See below.</li>
<li><code>drive_oauth_client()</code> returns
<code>.auth$client</code>.</li>
<li><code>drive_api_key()</code> returns
<code>.auth$api_key</code>.</li>
<li><code>drive_auth_configure()</code> can be used to configure auth.
This is how an advanced user would enter their own OAuth client and API
key into the auth config, in order to affect all subsequent
requests.</li>
<li><code>drive_user()</code> reports some information about the user
associated with the current token. The Drive API offers an actual
endpoint for this, which is not true for most Google APIs. Therefore the
analogous function in bigrquery, <code>bq_user()</code> is a better
general reference.</li>
</ul>
</div>
<div id="de-auth" class="section level2">
<h2>De-auth</h2>
<p>APIs split into two classes: those that can be used, at least
partially, without a token and those that cannot. If an API is usable
without a token – which is true for the Drive API – such requests must
include an API key. Therefore, the auth design for a client package is
different for these two types of APIs.</p>
<p>For an API that can be used without a token:
<code>drive_deauth()</code> can be used at any time to enter a
de-authorized state. It sets <code>auth_active</code> to
<code>FALSE</code> and <code>.auth$cred</code> to <code>NULL</code>. In
this state, requests are sent out with an API key and no token. This is
a great way to eliminate any friction re: auth if there’s no need for
it, i.e. if all requests are for resources that are world readable or
available to anyone who knows how to ask for it, such as files shared
via “Anyone with the link”. The de-authorized state is especially useful
in non-interactive settings or where user interaction is indirect, such
as via Shiny.</p>
<p>For an API that cannot be used without a token: BigQuery is an
example of such an API. <code>bq_deauth()</code> just clears the current
token, so that the auth flow starts over the next time a token is
needed.</p>
</div>
<div id="bring-your-own-client-and-key" class="section level2">
<h2>Bring Your Own Client and Key</h2>
<p>Advanced users can use their own OAuth client and API key.
<code>drive_auth_configure()</code> lives in <code>R/drive_auth.R</code>
and it provides the ability to modify the current <code>client</code>
and <code>api_key</code>. Recall that <code>drive_oauth_client()</code>
and <code>drive_api_key()</code> also exist for targeted, read-only
access.</p>
<p>The <code>vignette(&quot;get-api-credentials&quot;)</code> describes how to get
an API key and OAuth client.</p>
<p>Packages that always send a token will omit the API key functionality
here.</p>
</div>
<div id="changing-identities-and-more" class="section level2">
<h2>Changing identities (and more)</h2>
<p>One reason for a user to call <code>drive_auth()</code> directly and
proactively is to switch from one Google identity to another or to make
sure they are presenting themselves with a specific identity.
<code>drive_auth()</code> accepts an <code>email</code> argument, which
is honored when gargle determines if there is already a suitable token
on hand. Here is a sketch of how a user could switch identities during a
session, possibly non-interactive:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">library</span>(googledrive)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="fu">drive_auth</span>(<span class="at">email =</span> <span class="st">&quot;janedoe_work@gmail.com&quot;</span>)</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co"># do stuff with Google Drive here, with Jane Doe&#39;s &quot;work&quot; account</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a><span class="fu">drive_auth</span>(<span class="at">email =</span> <span class="st">&quot;janedoe_personal@gmail.com&quot;</span>)</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co"># do other stuff with Google Drive here, with Jane Doe&#39;s &quot;personal&quot; account</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="fu">drive_auth</span>(<span class="at">path =</span> <span class="st">&quot;/path/to/a/service-account.json&quot;</span>)</span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co"># do other stuff with Google Drive here, using a service account</span></span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
